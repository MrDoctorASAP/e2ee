# Implementation note


# Авторизация

### Регистрация пользователя

```
Реализованно только на сервере
```

При регистрации пользователь указывает свои данные:
* Уникальный логин пользователя
* Пароль
* Email (необязательно)

Клиентское приложение посылает запрос на сервер: (путь `/api/v1/auth/register`)

В ответ получает jwt токен (Подробнее описанно далее)

### Вход пользователя

При входе пользователь указывает свои данные:
* Уникальный логин пользователя
* Пароль

Клиентское приложение посылает запрос на сервер: 

[ChatApi.ts:66](https://github.com/MrDoctorASAP/e2ee/blob/main/frontend/src/api/ChatApi.ts#L66)
```ts
export async function login(userCredentials: IUserCredentials): Promise<IAuth|null> {
  return await post('/api/v1/auth/login', userCredentials)
}
```

В ответе сервера содержится следующая информация:
```json
{
  "userId": 1,
  "username": "admin",
  "token": "..."
}
```

* `userId` - идентификатор пользователя
* `username` - логин пользователя
* `token` - специальный jwt токен

После успешной авторизации эта информация сохраняется в локальное хранилище и переиспользуется:

[SecureChatStorage.ts:8](https://github.com/MrDoctorASAP/e2ee/blob/main/frontend/src/model/SecureChatStorage.ts#L8)

```ts
export function storeAuth(auth: IAuth) {
  if (!auth) return
  localStorage.setItem('AUTH', JSON.stringify(auth))
}
```

При следующем входе на страницу она будет загруженна:

[SecureChatStorage.ts:14](https://github.com/MrDoctorASAP/e2ee/blob/main/frontend/src/model/SecureChatStorage.ts#L14)

```ts
export function loadAuth() {
  const auth = localStorage.getItem('AUTH')
  if (!auth) return null
  return JSON.parse(auth)
}
```

### Авторизованные запросы

При запросах к серверу требующих авторизации в запрос включается `token`.
По этому токену сервер сможет идентифицировать пользователя и проверить подлинность запроса

Токен включается в заголовок запроса в следующем формате:

```
authorization: Bearer [token]
```

Пример кода:
[ChatApi.ts:25](https://github.com/MrDoctorASAP/e2ee/blob/main/frontend/src/api/ChatApi.ts#L25)
```js
fetch(url, {
  headers: {
    'authorization': 'Bearer ' + token
  }
})

```

Страница логина - [LoginPage.jsx](https://github.com/MrDoctorASAP/e2ee/blob/main/frontend/src/ref/components/LoginPage.jsx)

### Jwt token
Jwt token - стандарт авторизации
https://ru.wikipedia.org/wiki/JSON_Web_Token

# Личные и груповые чаты

При отпралении сообщений в **персональные** и **груповые** чаты, серверу передаётся информация:
* Идентификатор чата
* Текст сообщения

Сообщения шифруются при передаче между клиентом и сервером по протоколу HTTPS, когда сообщения пришли на сервер, теоритически они могут быть прочитаны.
На деле сервер не читает сообщения, а только перенаправляет их в базу данных, в которой они хранятся в зашифрованном виде.

# Секретные чаты

Секретные чаты имеют ряд значительных отличий:

Сообщения не хранятся на сервере. Постоянный доступ к расшифрованным сообщениям имеют только учатники секретного чата.

Сообщения на сервере сохраняются, только в одном случае: когда получатель не в сети.
В таком случае сообщения будут сохранены до момента их получения клиентом, после чего будут удалены. Однако сервер не может прочитать содержимое сообщений, по скольку не имеет ключа шифрования.

При передаче сообщений на сервер используется [сквозное шифрование](https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B2%D0%BE%D0%B7%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

Сквозное шифрование - метод обмена информацией, при котором только участники общения имеют доступ к сообщениям.
В основе сквозного шифрования лежит идея, что ключи шифрования известны только общающимся между собой сторонам.

В основе реадизации данного метода лежит симметричное шифрование сообщений общим ключём. При передаче сообщения отправитель шифрует сообщение своим ключём, а получатель расшифровает. Таким образом третья сторона не имеет доступа к информации.

Для данного подхода, необходимо получить этот общий симметричный ключ таким образом, что бы он был только у получателя и отправителя.

Для реализации обмена ключей был выбран [протокол Диффи — Хеллмана на эллиптических кривых](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%94%D0%B8%D1%84%D1%84%D0%B8_%E2%80%94_%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0_%D0%BD%D0%B0_%D1%8D%D0%BB%D0%BB%D0%B8%D0%BF%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85_%D0%BA%D1%80%D0%B8%D0%B2%D1%8B%D1%85)

Этот протокол имеет стандартизированную реализацию и доступен по средствам Web API [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#ecdh).

Полная схема обмена ключами описанна в файле [KeyExchange2.pdf](https://github.com/MrDoctorASAP/e2ee/blob/main/doc/KeyExchange2.pdf)

После обмена только отправитель и получатель имеют общий секретный ключ, который будет использован для шифрования сообщений.

Сообщения шифруются по алгоритму [AES-GCM](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#aes-gcm)

Одно из основных отличий этого режима от других заключается в том, что GCM является режимом с «аутентификацией», что означает, что он включает проверки того, что зашифрованный текст не был изменен злоумышленником.

Полная схема передачи сообщений описанна в файле [SecureMessage.pdf](https://github.com/MrDoctorASAP/e2ee/blob/main/doc/SecureMessage.pdf)

На сервер передаётся:
* Идентификатор секретного чата
* Зашифрованное сообщение
* Вектор иницилизации (IV) - Нужен для AES; Является публичной информацией.


